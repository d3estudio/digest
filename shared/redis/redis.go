package redis

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	log "github.com/Sirupsen/logrus"
	"github.com/d3estudio/digest/shared"
	"gopkg.in/redis.v5"
)

// Client provides a high-level abstration to an underlying Redis client.
type Client struct {
	client *redis.Client
}

// Setup prepares the undelying Redis client to connect to the remote server
// by reading configuration options from the Settings model
func (c *Client) Setup() {
	addr := fmt.Sprintf("%s:%d", shared.Settings.RedisServer, shared.Settings.RedisPort)
	log.Debug("Connecting to ", addr)
	c.client = redis.NewClient(&redis.Options{
		Addr: addr,
	})
	_, err := c.client.Ping().Result()
	if err != nil {
		log.Error("Error connecting to Redis", err)
	}
	log.Debug("Redis connected.")
}

func queueForItem(item interface{}) string {
	targetQueueComponent := strings.Join(shared.SplitCamelCase(reflect.TypeOf(item).Name()), "_")
	return fmt.Sprintf("%s.%s", shared.Settings.BaseQueueName, strings.ToLower(targetQueueComponent))
}

// PushItem pushes a given interface into a specific queue by encoding it into
// an Gob. Please notice that it is not advisable to push unknown structures,
// that is any structure outside the d3estudio/digest/shared/models package.
// The destination queue name is generated by joining the BaseQueueName field
// gathered from the Settings model with the snake_cased name of the Struct type
// defining the provided item.
func (c *Client) PushItem(item interface{}) {
	targetQueue := queueForItem(item)
	buffer := bytes.Buffer{}
	e := json.NewEncoder(&buffer)
	err := e.Encode(item)
	if err != nil {
		log.Error("Failed encoding item before pushing: ", err)
		return
	}
	log.WithField("queue", targetQueue).Debug(fmt.Sprintf("Pushing %d bytes", buffer.Len()))
	c.client.RPush(targetQueue, buffer.Bytes())
}

func (c *Client) SubscribeToQueueOfType(data interface{}, output chan interface{}) {
	queue := queueForItem(data)
	cachedDataType := reflect.TypeOf(data)
	for {
		res, err := c.client.BLPop(0, queue).Result()
		if err != nil {
			log.WithField("queue", queue).Error("Error blpopping: ", err)
			continue
		}
		buffer := bytes.Buffer{}
		buffer.Write([]byte(res[1]))
		e := json.NewDecoder(&buffer)
		i := reflect.New(cachedDataType).Interface()
		err = e.Decode(&i)
		if err != nil {
			log.WithField("queue", queue).Error("Error decoding: ", err)
			continue
		}
		output <- i
	}
}
